#include "verilator/verilator.h"

#include <sstream>

namespace hal
{
    namespace verilator
    {
        const std::string get_saleae_parser_h()
        {
            std::stringstream saleae_parser_h;
            saleae_parser_h << "#pragma once\n"
                            << "#include <map>\n"
                            << "#include <unordered_map>\n"
                            << "#include <functional>\n"
                            << "#include <verilated.h>\n"
                            << "\n"
                            << "\n"
                            << "class SaleaeFile;\n"
                            << "\n"
                            << "class SaleaeParser\n"
                            << "{\n"
                            << "    static std::string strim(std::string s);\n"
                            << "    struct WaveFormFile {\n"
                            << "        std::function<void(vluint8_t *obj, uint64_t, int)> callback;\n"
                            << "        std::string name;\n"
                            << "        SaleaeFile* file;\n"
                            << "        int value;\n"
                            << "        vluint8_t* obj;\n"
                            << "    };\n"
                            << "    std::multimap<uint64_t,WaveFormFile> mNextValueMap;\n"
                            << "    std::unordered_map<std::string,std::string> mSaleaeAbbrevMap;\n"
                            << "    std::string mCsvFilename;\n"
                            << "\n"
                            << "public:\n"
                            << "    static uint64_t sTimeScaleFactor;\n"
                            << "    SaleaeParser(const std::string& filename);\n"
                            << "    bool registerCallback(std::string& name, std::function<void(vluint8_t*,uint64_t, int)> callback, vluint8_t* obj);\n"
                            << "    bool nextEvent();\n"
                            << "};\n";
            return saleae_parser_h.str();
        }
        const std::string get_saleae_parser_cpp()
        {
            std::stringstream saleae_parser_cpp;
            saleae_parser_cpp << "#include \"saleae_parser.h\"\n"
                              << "#include \"saleae_file.h\"\n"
                              << "#include <fstream>\n"
                              << "#include <sstream>\n"
                              << "#include <stdio.h>\n"
                              << "#include <cctype>\n"
                              << "#include <experimental/filesystem>\n"
                              << "#include <iostream>\n"
                              << "\n"
                              << "uint64_t SaleaeParser::sTimeScaleFactor = 1000000000;\n"
                              << "\n"
                              << "SaleaeParser::SaleaeParser(const std::string& filename)\n"
                              << "    : mCsvFilename(filename)\n"
                              << "{\n"
                              << "    std::ifstream ff(mCsvFilename);\n"
                              << "    std::string line;\n"
                              << "    bool isKeyword = true;\n"
                              << "    while (std::getline(ff, line))\n"
                              << "    {\n"
                              << "        if (isKeyword)\n"
                              << "        {\n"
                              << "            if (line != \"<SALEAE>\") return;\n"
                              << "            isKeyword = false;\n"
                              << "        }\n"
                              << "\n"
                              << "        std::istringstream iss(line);\n"
                              << "        std::string token;\n"
                              << "        bool isName = false;\n"
                              << "\n"
                              << "        std::string abbrev;\n"
                              << "        std::string name;\n"
                              << "        while (std::getline(iss, token, ','))\n"
                              << "        {\n"
                              << "            if (isName)\n"
                              << "                name = strim(token);\n"
                              << "            else\n"
                              << "                abbrev = strim(token);\n"
                              << "            isName = true;\n"
                              << "        }\n"
                              << "        mSaleaeAbbrevMap[name] = abbrev;\n"
                              << "    }\n"
                              << "}\n"
                              << "\n"
                              << "std::string SaleaeParser::strim(std::string s)\n"
                              << "{\n"
                              << "    if (s.empty()) return s;\n"
                              << "    int p0 = 0;\n"
                              << "    int p1 = s.length()-1;\n"
                              << "    while (p0 <= p1 && isspace(s.at(p0))) p0++;\n"
                              << "    while (p0 <= p1 && isspace(s.at(p1))) p1--;\n"
                              << "    if (s.at(p0) == '\"' && s.at(p1) == '\"' && p1-p0 >= 2)\n"
                              << "    {\n"
                              << "        ++p0;\n"
                              << "        --p1;\n"
                              << "    }\n"
                              << "    return s.substr(p0,p1-p0+1);\n"
                              << "}\n"
                              << "\n"
                              << "bool SaleaeParser::nextEvent()\n"
                              << "{\n"
                              << "    auto it = mNextValueMap.begin();\n"
                              << "    if (it == mNextValueMap.end()) return false;\n"
                              << "    WaveFormFile wff = it->second;\n"
                              << "    mNextValueMap.erase(it);\n"
                              << "    wff.callback(wff.obj,it->first,wff.value);\n"
                              << "    wff.value = wff.value ? 0 : 1;\n"
                              << "    if (wff.file->good())\n"
                              << "    {\n"
                              << "        uint64_t nextT = wff.file->nextTimeValue();\n"
                              << "        mNextValueMap.insert(std::pair<uint64_t,WaveFormFile>(nextT,wff));\n"
                              << "    }\n"
                              << "    else\n"
                              << "        delete wff.file;\n"
                              << "    return true;\n"
                              << "}\n"
                              << "\n"
                              << "bool SaleaeParser::registerCallback(std::string& name, std::function<void(vluint8_t*,uint64_t,int)> callback, vluint8_t *obj)\n"
                              << "{\n"
                              << "    auto it = mSaleaeAbbrevMap.find(name);\n"
                              << "    if (it == mSaleaeAbbrevMap.end()) return false;\n"
                              << "    std::experimental::filesystem::path path(mCsvFilename);\n"
                              << "    path.replace_filename(std::string(\"digital_\") + it->second + \".bin\");\n"
                              << "    SaleaeFile* datafile = new SaleaeFile(path.string());\n"
                              << "    if (!datafile->good())\n"
                              << "    {\n"
                              << "        std::cerr << \"Error loading SALEAE datafile <\" << datafile->get_last_error() << \">\" << std::endl;\n"
                              << "        delete datafile;\n"
                              << "        return false;\n"
                              << "    }\n"
                              << "    mNextValueMap.insert(std::pair<uint64_t,WaveFormFile>(0,{callback, name, datafile, datafile->startValue(), obj}));\n"
                              << "    return true;\n"
                              << "}\n";
            return saleae_parser_cpp.str();
        }
        const std::string get_saleae_file_h()
        {
            std::stringstream saleae_file_h;
            saleae_file_h << "#pragma once\n"
                          << "\n"
                          << "#include <fstream>\n"
                          << "\n"
                          << "class SaleaeFile : public std::ifstream\n"
                          << "{\n"
                          << "    char mIdent[9];\n"
                          << "    int32_t mVersion;\n"
                          << "    int32_t mType;\n"
                          << "    uint32_t mValue;\n"
                          << "    double mBeginTime;\n"
                          << "    double mEndTime;\n"
                          << "    uint64_t mNumTransitions;\n"
                          << "    uint64_t mNumRead;\n"
                          << "\n"
                          << "    std::string mErrorMessage;\n"
                          << "\n"
                          << "    void failed(const std::string& msg);\n"
                          << "public:\n"
                          << "    SaleaeFile(const std::string& filename);\n"
                          << "    int startValue() const { return mValue; }\n"
                          << "\n"
                          << "    uint64_t nextTimeValue();\n"
                          << "    std::string get_last_error() const { return mErrorMessage; }\n"
                          << "};\n";
            return saleae_file_h.str();
        }
        const std::string get_saleae_file_cpp()
        {
            std::stringstream saleae_file_cpp;
            saleae_file_cpp << "#include \"saleae_file.h\"\n"
                            << "#include \"saleae_parser.h\"\n"
                            << "\n"
                            << "#include <stdio.h>\n"
                            << "#include <math.h>\n"
                            << "\n"
                            << "SaleaeFile::SaleaeFile(const std::string &filename)\n"
                            << "    : std::ifstream(filename, std::ios::binary), mNumRead(0)\n"
                            << "{\n"
                            << "    read(mIdent,8);\n"
                            << "    mIdent[8] = 0;\n"
                            << "    if (mIdent != std::string(\"<SALEAE>\"))\n"
                            << "    {\n"
                            << "        failed(\"No <SALEAE> identifier found\");\n"
                            << "        return;\n"
                            << "    }\n"
                            << "\n"
                            << "    read((char*)&mVersion,sizeof(mVersion));\n"
                            << "    read((char*)&mType,sizeof(mVersion));\n"
                            << "    if (mType != 0)\n"
                            << "    {\n"
                            << "        failed(\"Expected SALEAE type 0 (digital data)\");\n"
                            << "        return;\n"
                            << "    }\n"
                            << "\n"
                            << "    read((char*)&mValue,sizeof(mValue));\n"
                            << "    read((char*)&mBeginTime,sizeof(mBeginTime));\n"
                            << "    read((char*)&mEndTime,sizeof(mEndTime));\n"
                            << "    read((char*)&mNumTransitions,sizeof(mNumTransitions));\n"
                            << "\n"
                            << "    // printf(\"<%s> %d %d %d %.7f %.7f %lu\n\", mIdent, mVersion, mType, mValue, mBeginTime, mEndTime, mNumTransitions );\n"
                            << "}\n"
                            << "\n"
                            << "uint64_t SaleaeFile::nextTimeValue()\n"
                            << "{\n"
                            << "    double tval;\n"
                            << "    read((char*)&tval,sizeof(tval));\n"
                            << "    ++mNumRead;\n"
                            << "    if (mNumRead >= mNumTransitions) setstate(eofbit);\n"
                            << "    return floor( (tval-mBeginTime) * SaleaeParser::sTimeScaleFactor + 0.5);\n"
                            << "}\n"
                            << "\n"
                            << "void SaleaeFile::failed(const std::string& msg)\n"
                            << "{\n"
                            << "     mErrorMessage = msg;\n"
                            << "     setstate(failbit);\n"
                            << "}\n";
            return saleae_file_cpp.str();
        }
        const std::string get_saleae_parser_h()
        {
            std::stringstream saleae_parser_h;
            saleae_parser_h << "#pragma once\n"
                            << "#include <map>\n"
                            << "#include <unordered_map>\n"
                            << "#include <functional>\n"
                            << "#include <verilated.h>\n"
                            << "\n"
                            << "\n"
                            << "class SaleaeFile;\n"
                            << "\n"
                            << "class SaleaeParser\n"
                            << "{\n"
                            << "    static std::string strim(std::string s);\n"
                            << "    struct WaveFormFile {\n"
                            << "        std::function<void(vluint8_t *obj, uint64_t, int)> callback;\n"
                            << "        std::string name;\n"
                            << "        SaleaeFile* file;\n"
                            << "        int value;\n"
                            << "        vluint8_t* obj;\n"
                            << "    };\n"
                            << "    std::multimap<uint64_t,WaveFormFile> mNextValueMap;\n"
                            << "    std::unordered_map<std::string,std::string> mSaleaeAbbrevMap;\n"
                            << "    std::string mCsvFilename;\n"
                            << "\n"
                            << "public:\n"
                            << "    static uint64_t sTimeScaleFactor;\n"
                            << "    SaleaeParser(const std::string& filename);\n"
                            << "    bool registerCallback(std::string& name, std::function<void(vluint8_t*,uint64_t, int)> callback, vluint8_t* obj);\n"
                            << "    bool nextEvent();\n"
                            << "};\n";
        }
        const std::string get_makefile_template()
        {
            std::stringstream makefile_template;
            makefile_template << "#!/bin/bash\n"
                              << "\n"
                              << "#### CONFIG ####\n"
                              << "design_name=\"V<design_name>\"\n"
                              << "verilator_base_command=\"verilator -I. -Wall -Wno-fatal --MMD -trace-fst <num_of_trace_threads> -y gate_definitions/ --Mdir obj_dir <num_of_binary_trace_threads> "
                                 "--noassert --exe -cc -DSIM_VERILATOR --trace-depth 1\"\n"
                              << "num_of_build_threads=<num_of_build_threads>\n"
                              << "final_compile_base_command=\'g++  -Llib   testbench.o verilated.o verilated_fst_c.o <verilated_threads.o> \'\"$design_name\"\'__ALL.a   -lz  -pthread -lpthread "
                                 "-latomic   -o \'\"$design_name\"\' -lm -lstdc++\'\n"
                              << "\n"
                              << "#### DO NOT TOUCH ####\n"
                              << "echo \"Automated Simulation Script\"\n"
                              << "echo\n"
                              << "\n"
                              << "declare -a parts\n"
                              << "\n"
                              << "echo \"collecting files\"\n"
                              << "# collect all cpp files\n"
                              << "for entry in *.cpp\n"
                              << "do\n"
                              << "    if [[ $entry == *\"part\"* ]]; then\n"
                              << "        parts+=(\"${entry/.cpp/\"\"}\")\n"
                              << "    fi\n"
                              << "done\n"
                              << "\n"
                              << "\n"
                              << "echo \"found ${#parts[@]} part file(s)\"\n"
                              << "echo\n"
                              << "\n"
                              << "echo \"starting verilator...\"\n"
                              << "\n"
                              << "# building verilator command\n"
                              << "verilator_command=\"$verilator_base_command\"\n"
                              << "\n"
                              << "for entry in \"${parts[@]}\"\n"
                              << "do\n"
                              << "    verilator_command+=\" $entry.cpp\"\n"
                              << "done\n"
                              << "\n"
                              << "verilator_command+=\" testbench.cpp chip.v\"\n"
                              << "\n"
                              << "$verilator_command\n"
                              << "ret_code=$?\n"
                              << "if [ $ret_code != 0 ]; then\n"
                              << "    printf \'error in verilator, %d\n\' $ret_code\n"
                              << "    exit $ret_code\n"
                              << "fi\n"
                              << "\n"
                              << "make -j$num_of_build_threads --no-print-directory -C obj_dir/ -f $design_name.mk\n"
                              << "\n"
                              << "ret_code=$?\n"
                              << "\n"
                              << "#fallback: try building $design_name with dynamic library\n"
                              << "if [ $ret_code != 0 ]; then\n"
                              << "    printf \'error in compilation, using fallback, return code: %d\n\' $ret_code\n"
                              << "    mkdir obj_dir/lib\n"
                              << "    export LD_LIBRARY_PATH=obj_dir/lib/:$LD_LIBRARY_PATH\n"
                              << "\n"
                              << "    final_compile_command=\"$final_compile_base_command\"\n"
                              << "\n"
                              << "    for entry in \"${parts[@]}\"\n"
                              << "    do\n"
                              << "        o_file=\"obj_dir/$entry.o\"\n"
                              << "        so_file=\"obj_dir/lib/lib$entry.so\"\n"
                              << "\n"
                              << "        if test -f \"$o_file\"; then\n"
                              << "            gcc -shared -o $so_file $o_file\n"
                              << "        else \n"
                              << "            echo \"missing .o file, fallback failed, abort...\"\n"
                              << "            exit ret_code\n"
                              << "        fi\n"
                              << "\n"
                              << "        final_compile_command+=\" -l$entry\"\n"
                              << "\n"
                              << "    done\n"
                              << "    cd obj_dir\n"
                              << "    $final_compile_command\n"
                              << "    cd ..\n"
                              << "    ret_code=$?\n"
                              << "    if [ $ret_code != 0 ]; then\n"
                              << "        echo \"compile with dynamic link failed, exiting now...\"\n"
                              << "        exit $ret_code\n"
                              << "    fi\n"
                              << "fi\n"
                              << "\n"
                              << "obj_dir/$design_name";
            return makefile_template.str();
        }

        const std::string get_testbench_cpp_template()
        {
            std::stringstream testbench_cpp_template;
            testbench_cpp_template << "#include <stdlib.h>\n"
                                   << "#include <iostream>\n"
                                   << "#include <verilated.h>\n"
                                   << "#include <verilated_fst_c.h>\n"
                                   << "#include \"V<top_system>.h\"\n"
                                   << "#include \"testbench.h\"\n"
                                   << "\n"
                                   << "#define MAX_SIM_TIME 20\n"
                                   << "vluint64_t sim_time = 0;\n"
                                   << "\n"
                                   << "double sc_time_stamp(){\n"
                                   << "\treturn sim_time;\n"
                                   << "}\n"
                                   << "\n"
                                   << "int main(int argc, char** argv, char** env) {\n"
                                   << "    V<top_system> *dut = new V<top_system>;\n"
                                   << "\n"
                                   << "    Verilated::traceEverOn(true);\n"
                                   << "    VerilatedFstC *m_trace = new VerilatedFstC;\n"
                                   << "\n"
                                   << "\n"
                                   << "    dut->trace(m_trace, 1);\n"
                                   << "    m_trace->open(\"waveform.fst\");\n"
                                   << "\n"
                                   << "<insert_trace_here>\n"
                                   << "\n"
                                   << "\tm_trace->dump(sim_time);\n"
                                   << "    m_trace->close();\n"
                                   << "    delete dut;\n"
                                   << "    exit(EXIT_SUCCESS);\n"
                                   << "}";
            return testbench_cpp_template.str();
        }
    }    // namespace verilator
}    // namespace hal